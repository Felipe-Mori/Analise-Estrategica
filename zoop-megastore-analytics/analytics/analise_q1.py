# -*- coding: utf-8 -*-
"""Etapa1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AxsU_nwV2n9tyUrzuyT054T_C6SDuI1N
"""

# -*- coding: utf-8 -*-
# ================================================
# Análise de Vendas - Q1 (diretoria, leigos)
# - Lê vendas.csv e clientes.csv (separador detectado)
# - Normaliza colunas e deriva "receita"
# - Seleciona o Q1 do ano mais recente com dados
# - KPIs: Receita, Pedidos, Ticket Médio, Clientes Ativos, YoY (se houver base)
# - Destaques: Ranking de Categorias (com participação %), Receita mensal (Jan-Fev-Mar)
# - Extra didático: Novos vs. Recorrentes no Q1 (se houver histórico anterior)
# - Saída: Resumo Executivo (texto), tabelas e gráficos (sem salvar arquivos)
# Requisitos: pandas, numpy, matplotlib (presentes no Colab)
# ================================================

import math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# -------- Aparência de impressão (didática) --------
pd.options.display.float_format = lambda x: f"{x:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

# -------- Helpers --------
def normalize_cols(df: pd.DataFrame) -> pd.DataFrame:
    """Normaliza nomes de colunas para facilitar a detecção."""
    out = df.copy()
    out.columns = (
        out.columns.str.strip()
        .str.lower()
        .str.replace(" ", "_")
        .str.replace("-", "_")
        .str.normalize("NFKD")
        .str.encode("ascii", errors="ignore")
        .str.decode("ascii")
    )
    return out

def brl(x):
    """Formata número em Real brasileiro."""
    try:
        return f"R$ {x:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
    except Exception:
        return str(x)

def try_read_csv(path):
    """Lê CSV tentando detectar separador automaticamente."""
    return pd.read_csv(path, sep=None, engine="python")

# -------- 1) Carregar dados --------
vendas = try_read_csv("vendas.csv")
clientes = try_read_csv("clientes.csv")

vendas = normalize_cols(vendas)
clientes = normalize_cols(clientes)

# -------- 2) Mapear colunas-chave --------
date_candidates = ["data_venda", "data", "date", "order_date", "dt_venda", "pedido_data"]
order_candidates = ["id_venda", "id_pedido", "pedido_id", "order_id"]
cust_candidates  = ["id_cliente", "cliente_id", "customer_id"]
cat_candidates   = ["categoria", "category", "grupo", "departamento"]

qty_candidates   = ["quantidade", "qtd", "qty"]
price_candidates = ["preco_unitario", "unit_price", "price", "preco"]
total_candidates = ["valor_venda", "valor_total", "total", "receita", "faturamento", "vl_total", "valor"]

date_col = next((c for c in date_candidates if c in vendas.columns), None)
order_col = next((c for c in order_candidates if c in vendas.columns), None)
cust_col  = next((c for c in cust_candidates  if c in vendas.columns), None)
cat_col   = next((c for c in cat_candidates   if c in vendas.columns), None)

qty_col   = next((c for c in qty_candidates   if c in vendas.columns), None)
price_col = next((c for c in price_candidates if c in vendas.columns), None)
total_col = next((c for c in total_candidates if c in vendas.columns), None)

if date_col is None:
    raise RuntimeError("Coluna de data não encontrada (ex.: data_venda, data, date, dt_venda).")

# -------- 3) Preparar campos: data e receita --------
# Converte data (dayfirst=True para padrão pt-BR)
vendas[date_col] = pd.to_datetime(vendas[date_col], errors="coerce", dayfirst=True, infer_datetime_format=True)
vendas = vendas.dropna(subset=[date_col])

# Deriva receita (prioriza coluna total; senão quantidade * preço)
if total_col is not None:
    # Trata casos com vírgula decimal
    vendas["receita"] = (
        vendas[total_col].astype(str)
        .str.replace(".", "", regex=False)
        .str.replace(",", ".", regex=False)
    )
    vendas["receita"] = pd.to_numeric(vendas["receita"], errors="coerce")
elif qty_col is not None and price_col is not None:
    for c in (qty_col, price_col):
        vendas[c] = (
            vendas[c].astype(str)
            .str.replace(".", "", regex=False)
            .str.replace(",", ".", regex=False)
        )
        vendas[c] = pd.to_numeric(vendas[c], errors="coerce")
    vendas["receita"] = vendas[qty_col] * vendas[price_col]
else:
    raise RuntimeError("Não foi possível derivar a receita. Informe 'valor_venda/total/receita' OU 'quantidade' e 'preco_unitario'.")

# Limpa NaN/negativos de receita (se houver)
vendas = vendas[pd.to_numeric(vendas["receita"], errors="coerce").notna()]
vendas = vendas[vendas["receita"] >= 0]

# Campos auxiliares de tempo
vendas["ano"] = vendas[date_col].dt.year
vendas["mes"] = vendas[date_col].dt.month

# -------- 4) Selecionar Q1 (Jan-Fev-Mar) do ano mais recente com dados --------
latest_year = int(vendas["ano"].max())
q1 = vendas[(vendas["ano"] == latest_year) & (vendas["mes"].isin([1, 2, 3]))].copy()

if q1.empty:
    # Se não houver Q1 no ano mais recente, pega o último ano que tenha Q1
    candidate_years = (
        vendas[vendas["mes"].isin([1, 2, 3])]
        .groupby("ano")["receita"]
        .sum()
        .sort_index(ascending=False)
    )
    if not candidate_years.empty:
        latest_year = int(candidate_years.index[0])
        q1 = vendas[(vendas["ano"] == latest_year) & (vendas["mes"].isin([1, 2, 3]))].copy()

if q1.empty:
    raise RuntimeError("Não há vendas no 1º trimestre (meses 1-3) em nenhum ano do arquivo.")

# -------- 5) KPIs principais --------
pedidos_q1 = q1[order_col].nunique() if order_col else len(q1)
clientes_ativos_q1 = q1[cust_col].nunique() if cust_col else np.nan
receita_q1 = float(q1["receita"].sum())
ticket_medio_q1 = float(receita_q1 / pedidos_q1) if pedidos_q1 else np.nan

# YoY (comparar com Q1 do ano anterior, se existir)
prev_year = latest_year - 1
q1_prev = vendas[(vendas["ano"] == prev_year) & (vendas["mes"].isin([1, 2, 3]))]
if not q1_prev.empty:
    receita_q1_prev = float(q1_prev["receita"].sum())
    yoy_receita = (receita_q1 / receita_q1_prev - 1.0) if receita_q1_prev != 0 else np.nan
else:
    receita_q1_prev = np.nan
    yoy_receita = np.nan

# -------- 6) Destaques por categoria (ranking + participação) --------
if cat_col and cat_col in q1.columns:
    cat_df = (
        q1.groupby(cat_col, dropna=False)["receita"]
        .sum()
        .reset_index()
        .rename(columns={cat_col: "categoria"})
        .sort_values("receita", ascending=False)
    )
else:
    q1["categoria"] = "Sem categoria"
    cat_df = q1.groupby("categoria")["receita"].sum().reset_index()

cat_df["participacao_%"] = (cat_df["receita"] / receita_q1 * 100.0).round(2)
TOPN = min(10, len(cat_df))
cat_top = cat_df.head(TOPN).copy()

# -------- 7) Receita mensal no Q1 (para ver ritmo) --------
mes_map = {1: "Jan", 2: "Fev", 3: "Mar"}
mensal_q1 = (
    q1.groupby("mes")["receita"].sum().reindex([1, 2, 3], fill_value=0).reset_index()
)
mensal_q1["mes_nome"] = mensal_q1["mes"].map(mes_map)

# -------- 8) Novos vs Recorrentes (didático p/ diretoria) --------
# "Novo": cliente que NUNCA comprou antes da primeira data do Q1 analisado.
novos = recorrentes = np.nan
if cust_col:
    inicio_q1 = q1[date_col].min()
    # clientes com compra anterior ao início do Q1
    clientes_historico = set(vendas[vendas[date_col] < inicio_q1][cust_col].unique())
    clientes_q1 = q1[cust_col].unique()
    novos_clientes = [c for c in clientes_q1 if c not in clientes_historico]
    recorrentes_clientes = [c for c in clientes_q1 if c in clientes_historico]

    novos = len(novos_clientes)
    recorrentes = len(recorrentes_clientes)

    receita_novos = q1[q1[cust_col].isin(novos_clientes)]["receita"].sum() if novos_clientes else 0.0
    receita_recorrentes = q1[q1[cust_col].isin(recorrentes_clientes)]["receita"].sum() if recorrentes_clientes else 0.0
else:
    receita_novos = receita_recorrentes = np.nan

# -------- 9) RESUMO EXECUTIVO (texto para leigos) --------
linhas = []
linhas.append("="*68)
linhas.append(f"RESUMO EXECUTIVO — 1º TRIMESTRE (Q1 {latest_year})")
linhas.append("="*68)
linhas.append(f"- Receita total do trimestre: {brl(receita_q1)}")
linhas.append(f"- Número de pedidos: {pedidos_q1}")
linhas.append(f"- Ticket médio por pedido: {brl(ticket_medio_q1)}")
if not (isinstance(receita_q1_prev, float) and math.isnan(receita_q1_prev)):
    ytxt = f"{(yoy_receita*100):.1f}%"
    linhas.append(f"- Variação vs Q1 {latest_year-1}: {ytxt}")
if not (isinstance(clientes_ativos_q1, float) and math.isnan(clientes_ativos_q1)):
    linhas.append(f"- Clientes ativos no trimestre: {int(clientes_ativos_q1)}")

# Destaques de categorias (Top 3)
top3 = cat_df.head(3).copy()
if not top3.empty:
    partes = [f"{row['categoria']} ({brl(row['receita'])}, {row['participacao_%']:.2f}%)" for _, row in top3.iterrows()]
    linhas.append("- Categorias de maior destaque (Top 3): " + " | ".join(partes))

# Novos vs Recorrentes
if not (isinstance(novos, float) and math.isnan(novos)):
    p_novos = (receita_novos/receita_q1*100) if receita_q1 else 0
    p_rec = (receita_recorrentes/receita_q1*100) if receita_q1 else 0
    linhas.append(f"- Base de clientes: {novos} novos vs {recorrentes} recorrentes")
    linhas.append(f"  · Receita: {brl(receita_novos)} de novos ({p_novos:.1f}%) | {brl(receita_recorrentes)} de recorrentes ({p_rec:.1f}%)")

linhas.append("\nO QUE ISSO SIGNIFICA (em linguagem simples):")
linhas.append("• O trimestre mostra o tamanho do nosso mercado no começo do ano (Jan–Mar).")
linhas.append("• O ticket médio indica quanto, em média, entra de receita por pedido.")
if not (isinstance(receita_q1_prev, float) and math.isnan(receita_q1_prev)):
    if yoy_receita > 0:
        linhas.append("• Crescemos versus o mesmo período do ano anterior, sinal de tração positiva.")
    elif yoy_receita < 0:
        linhas.append("• Ficamos abaixo do mesmo período do ano anterior, atenção a volume/preço.")
    else:
        linhas.append("• Estamos estáveis vs. o mesmo período do ano anterior.")
linhas.append("• As categorias líderes são responsáveis por grande parte do faturamento — priorize estoque, preço e campanhas nelas.")
linhas.append("="*68)

print("\n".join(linhas))

# -------- 10) TABELAS AMIGÁVEIS --------
print("\nRANKING DE CATEGORIAS (Q1):")
cat_print = cat_df.copy()
cat_print["Receita (R$)"] = cat_print["receita"].apply(lambda x: float(f"{x:.2f}"))
cat_print["Participação (%)"] = cat_print["participacao_%"]
display(cat_print[["categoria", "Receita (R$)", "Participação (%)"]].rename(columns={"categoria":"Categoria"}))

print("\nRECEITA MENSAL NO Q1:")
mensal_print = mensal_q1.copy()
mensal_print["Receita (R$)"] = mensal_print["receita"].apply(lambda x: float(f"{x:.2f}"))
display(mensal_print[["mes_nome", "Receita (R$)"]].rename(columns={"mes_nome":"Mês"}))

# -------- 11) GRÁFICOS (matplotlib; 1 por figura; sem definir cores) --------
# Gráfico 1: Top categorias
plt.figure()
plt.bar(cat_top["categoria"].astype(str), cat_top["receita"])
plt.title(f"Top {TOPN} Categorias por Receita - Q1 {latest_year}")
plt.xlabel("Categoria")
plt.ylabel("Receita (R$)")
plt.xticks(rotation=45, ha="right")
plt.tight_layout()
plt.show()

# Gráfico 2: Receita mensal (Jan–Fev–Mar)
plt.figure()
plt.plot(mensal_q1["mes_nome"], mensal_q1["receita"], marker="o")
plt.title(f"Receita Mensal - Q1 {latest_year}")
plt.xlabel("Mês")
plt.ylabel("Receita (R$)")
plt.tight_layout()
plt.show()